# ICS2 期末复习笔记 （FS+IO与并发）

@2025-06-09 by nictheboy

整理了期末考试范围内全部 PPT 中的重点内容和习题。

## Persistence: I/O and Filesystems

### I/O Devices

#### 磁盘

| 特性/算法 | SSTF (Shortest Seek Time First) | Elevator (SCAN) | C-SCAN (Circular SCAN) | SPTF (Shortest Positioning Time First) |
|---|---|---|---|---|
| **基本思想** | 总是选择与当前磁头位置距离最近的请求进行服务，以最小化寻道时间。 | 磁头从磁盘一端向另一端移动，沿途服务请求，到达一端后反向移动，继续服务。模仿电梯。 | 磁头从磁盘一端向另一端移动，沿途服务请求，到达一端后立即跳回磁盘的另一端（通常是起始端），并再次从该方向开始服务。返回时不服务任何请求。 | 选择寻道时间和旋转延迟总和最小的请求进行服务。SSTF的扩展，考虑了旋转延迟。 |
| **寻道时间优化** | 局部最优，理论上总寻道时间最短。 | 整体寻道时间较好，避免了磁头频繁换向。 | 整体寻道时间较好，但有返回时的“空跑”时间。 | 理论上总访问时间（寻道+旋转）最短。 |
| **公平性** | 较差，可能导致“饥饿”现象（距离远的请求可能长时间得不到服务）。 | 较好，所有请求最终都能得到服务，但中间区域的请求服务频率更高。 | 更好，提供了更均匀的等待时间，避免了SCAN的饥饿问题，因为所有请求都按相同方向被扫描。 | 较差，同样可能导致“饥饿”现象，尤其是不考虑请求等待时间的情况下。 |
| **实现复杂度** | 较高，需要计算所有待处理请求与当前磁头的距离，并找出最小值。 | 中等，需要维护方向状态。 | 中等，需要维护方向状态和返回机制。 | 较高，需要同时计算寻道时间和旋转延迟。 |
| **吞吐量** | 高 | 高 | 较高 | 很高 |
| **响应时间方差** | 高 | 较低 | 较低，更均匀 | 高 |
| **优缺点** | **优点:** 平均寻道时间最短，吞吐量高。 **缺点:** 可能导致饥饿，响应时间方差大，磁头频繁换向增加机械磨损。 | **优点:** 避免饥饿，寻道效率较高，响应时间方差低。 **缺点:** 对两端请求不公平（需要等待磁头到达），可能存在不必要的全盘扫描。 | **优点:** 避免饥饿，更均匀的等待时间，寻道效率高。 **缺点:** 磁头返回时空跑，增加了总寻道时间。 | **优点:** 理论上最小化总访问时间（寻道+旋转）。 **缺点:** 饥饿问题比SSTF更严重，实际中很难精确预测旋转延迟，实现复杂。 |
| **适用场景** | 对平均寻道时间要求高，但对公平性要求不高的批处理系统。 | 适合中高负载系统，对公平性有一定要求的通用系统。 | 适合高负载系统，需要更均匀的等待时间，例如实时系统或大型数据库。 | 理论上更优，但在实际中由于难以精确计算旋转延迟，不如SSTF或SCAN/C-SCAN常用。 |

**简要说明:**

* **寻道时间 (Seek Time):** 磁头从当前磁道移动到目标磁道所需的时间。
* **旋转延迟 (Rotational Latency):** 磁头到达目标磁道后，等待目标扇区旋转到磁头下方所需的时间。
* **SPTF** 是 **SSTF** 的一个更“理想化”的版本，因为它不仅考虑了寻道时间，还尝试最小化旋转延迟。然而，在实际系统中，准确预测和利用旋转延迟是相当复杂的，因为磁盘旋转是持续的，且难以精确同步。因此，SPTF更多地存在于理论研究中，或者在一些特定硬件（如MEMS存储设备）上有所应用，但在传统的机械硬盘上，其优势往往不明显，甚至可能因为计算开销和难以精确控制而导致性能下降。在许多操作系统教材中，有时会将SSTF作为Shortest Positioning Time First的近似，因为它主要关注寻道时间的优化。

![习题 1](img/1-1.png)

![习题 1](img/1-2.png)

#### 固态硬盘

**混合映射 (Hybrid Mapping)**：

混合映射的核心思想之一是引入**日志块**。它将闪存空间分为两种类型的块：

* **数据块（Data Block）**：存储相对稳定、不经常更新的数据。这些块通常采用块级映射，以节省映射表空间。
* **日志块（Log Block）**：专门用于处理随机写入和更新操作。当主机写入或更新少量数据时，这些数据会被写入日志块中的新页面。日志块通常采用页面级映射，以便灵活地记录新的逻辑页面到物理页面的映射关系。

当一个日志块被填满，或者其中包含的有效数据（即没有被更新或删除的数据）数量较少时，SSD会触发一个“**合并（Merge）**”操作。这个操作会将日志块中的有效数据与它所对应的数据块中的有效数据合并到一个新的空闲数据块中，然后擦除旧的日志块和数据块。这个过程类似于日志结构文件系统（LFS）中的清理操作。

![习题 2](img/2-1.png)

![习题 2](img/2-2.png)

![习题 2](img/2-3.png)

![习题 2](img/2-4.png)

### Unix I/O

![图 1](img/F-1.png)

应用程序只需要维护文件描述符，其他信息都在kernel数据结构中。

一个应用程序可以通过seek操作，显式的设置文件的当前访问位置。

一个进程的文件描述符有上限。

The next file that is opened is guaranteed to receive the smallest available descriptor in the pool.

| FD | File |
| - | - |
| 0 | stdin |
| 1 | stdout |
| 2 | stderr |

![习题 3](img/3.png)

答案：3

### Reading File Metadata

![图 2-1](img/F-2-1.png)

![图 2-2](img/F-2-2.png)

### Sharing Files & I/O redirection

![习题 4](img/4.png)

答案：f

![习题 5](img/5.png)

答案：o

dup2() 函数会修改fd表，但是不会修改open file table。

![图 3-1](img/F-3-1.png)

![图 3-2](img/F-3-2.png)

### Linux I/O Stack

| 特性/算法     | NOOP (No Operation)                                  | Deadline                                                 | CFQ (Completely Fair Queuing)                               |
|---------------|------------------------------------------------------|----------------------------------------------------------|-------------------------------------------------------------|
| **主要目标**   | 最小化CPU开销，尽可能简单。                               | 保证请求的截止时间，防止饿死，读请求优先。                     | 在进程间公平分配I/O带宽。                                    |
| **工作机制**   | 简单的先进先出(FIFO)队列，会合并相邻的I/O请求。           | 为读写维护独立的FIFO队列和按截止时间排序的队列。读请求有更高优先级。每个请求有过期时间，调度器尝试在过期前服务它。 | 为每个进程维护I/O队列。给每个进程队列分配时间片和请求数配额，轮询服务。尝试优化同步I/O以提高交互性。 |
| **优点**       | CPU开销极低；非常适合SSD/NVMe等快速存储设备（因为它们几乎没有寻道时间）；虚拟化环境中宿主机已进行调度时，客户机使用NOOP可避免重复调度。 | 对数据库（特别是读密集型）友好；提供可预测的I/O延迟；有效防止I/O饿死。 | 对多用户/多进程桌面系统提供良好的公平性；适合混合工作负载；能较好地平衡吞吐量和延迟。 |
| **缺点**       | 不进行复杂的请求重排序，不保证公平性；在传统机械硬盘上可能导致性能不佳；如果一个进程产生大量I/O，其他进程可能饥饿。 | 为满足截止时间可能牺牲总吞吐量；比NOOP复杂，CPU开销稍高。       | CPU开销相对较高；对于某些特定负载（如纯数据库服务器），吞吐量可能不如Deadline；对于SSD/NVMe设备，其复杂性可能带来不必要的开销。 |
| **适用场景**   | SSD/NVMe驱动器；CPU敏感型应用；虚拟机客户机（当宿主机有更智能的调度器时）；内存数据库等随机访问为主且存储极快的场景。 | 数据库服务器（如MySQL, PostgreSQL）；需要可预测I/O延迟的应用；实时系统。 | 桌面系统；多用户环境；混合读写和随机/顺序访问的通用服务器。       |
| **CPU 开销**   | 非常低                                                | 中等                                                     | 较高                                                        |
| **饿死可能性** | 可能（特别是对于产生少量I/O的进程）                       | 低 (设计目标就是防止饿死)                                   | 低 (设计目标是公平，间接防止饿死)                             |
| **公平性**     | 无显式公平性保证                                        | 基于请求截止时间，不完全是进程间的公平。                      | 高 (以进程为单位进行公平调度)                                |
| **复杂性**     | 非常简单                                              | 中等                                                     | 复杂                                                        |

### File System

树状结构 + 任意长度的文件

open() 可以用于创建文件

lseek() 本身不会直接导致磁盘的 seek 操作，后续的 read/write 才会

pread() 和 pwrite() 把 lseek 和 read/write 合起来作为一个原子操作

fsync(int fd) 强制dirty数据写回设备，数据写完后返回，性能比较差

| open() 的选项 | 说明 |
| - | - |
| O_TRUNK | 截断（如果文件已经存在，删除其原有内容）|
| O_APPEND | 追加（每次写入时，将数据追加到文件末尾）|

| open() 的选项 | 说明 |
| - | - |
| O_DIRECT | open可增加这个选项，跳过page cache，直接写到通用块层、I/O调度层，自己处理块对齐。只是承诺不拷贝到page cache，不承诺等所有数据都写完才返回，所以会比单独用O_SYNC, fsync要快一些 |
| O_SYNC | open可增加这个选项，同步模式，每次write后都调用fsync，所有数据写入设备成功才返回。但也可能在磁盘的缓存中，数据不一定100%安全。 |
| O_DIRECT \| O_SYNC | 同步模式，所有数据写入设备成功才返回。且跳过page cache，直接写到通用块层、I/O调度层。 |

| 软链接 | 硬链接 |
| - | - |
| 软链接包含另一个文件的路径，有独立 inode。 | 硬链接和指向的文件共享一个 inode。 |
| 软链接可以指向一个不存在的文件。 | 硬链接不能指向一个不存在的文件。 |
| 软链接可以指向一个目录。 | 硬链接不能指向一个目录。 |
| 软链接可以跨分区。 | 硬链接不能跨分区。 |
| 软链接的文件类型是 symbolic link。 | 硬链接的文件类型是 regular file。 |

### File System Implementation

见 OSTEP 第 40 章

### Fast File System

见 OSTEP 第 41 章

### FSCK and Journaling

见 OSTEP 第 42 章

## Parallelism: Threads and Locks

### Posix threads (Pthreads) interface

略

### Measuring Speedup

### Semaphores

| 信号量 | 说明 |
| - | - |
| P(s) |  while (s == 0) wait(); s--;  |
| V(s) |  s++;  |

### Mutex

### RwLock

### Spinlock

### Two-phase Locking

### CAS
